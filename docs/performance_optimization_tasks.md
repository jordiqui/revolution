# Plan de optimización de rendimiento para Revolution

Tras completar las tres propuestas previas sin mejoras medibles en las pruebas SPRT, se proponen las siguientes líneas de trabajo adicionales. Cada tarea está pensada para aislar un posible cuello de botella diferente del motor y facilitar comparaciones A/B mediante campañas SPRT controladas.

| Tarea | Objetivo | Cambios clave | Métrica principal | Riesgos y mitigaciones |
|-------|----------|---------------|-------------------|------------------------|
| **1. Extensiones selectivas guiadas por amenazas en QSearch** | Mitigar efectos horizonte sin disparar el factor de ramificación. | Introducir en `src/search.cpp` y `src/qsearch.cpp` extensiones limitadas cuando el rey propio esté bajo ataque directo o existan recapturas forzadas, reutilizando heurísticas de `SEE` para acotar profundidad. | Elo en SPRT STC 10+0.05 y porcentaje de `fail-high` correctos en nodos tácticos. | Explosión del árbol: añadir contadores de extensiones por nodo y abortar si se supera un umbral dinámico dependiente de la profundidad efectiva. |
| **2. Política adaptativa de reemplazo en la tabla de transposición** | Aumentar la calidad de las entradas conservadas en partidas largas. | Ajustar `src/tt.cpp` y `src/search.cpp` para incorporar buckets por edad y una métrica híbrida (profundidad + calidad de score) en la lógica `TT::probe`, exponiendo un parámetro `TTAgeMargin` en `ucioption.cpp`. | Elo en SPRT LTC 60+0.1 y ratio de `TT hits` con entradas válidas. | Riesgo de thrashing: instrumentar `tt.cpp` para registrar reemplazos forzados y revisar el consumo de memoria en hardware de 4 GB. |
| **3. Margen de futility dinámico basado en NNUE** | Evitar descartar movimientos prometedores en posiciones agudas. | Recalibrar en `src/search.cpp` los márgenes de `futility` para que dependan de la desviación estándar de la evaluación NNUE de los hijos inmediatos, obtenida mediante una pasada previa en la frontera. | Elo en SPRT STC 15+0.1 y variación en nodos visitados respecto a la base. | Latencia adicional: cachear las evaluaciones auxiliares y abortar la exploración si el presupuesto de nodos aumenta >8% en pruebas `bench`. |
| **4. Balance dinámico de tiempo y movimientos seguros** | Reducir derrotas por apuros de tiempo en TC cortos. | Incorporar en `src/timeman.cpp` una heurística que combine `MoveOverhead` histórico y la volatilidad del score para ajustar `time_for_move`, exponiendo estadísticas en el comando UCI `go`. | Elo en SPRT blitz 3+0.01 y número de banderas frente a la versión base. | Riesgo de desperdiciar tiempo en posiciones perdidas: fijar un límite inferior igual a `10%` del tiempo restante y validar con suites de finales. |
| **5. Canal incremental de presión sobre el rey en NNUE** | Capturar mejor las amenazas directas a los reyes en posiciones abiertas. | Extender `src/nnue/nnue_architecture.cpp` y `assets/nnue/features/` con un canal que cuente atacantes por anillo y fase, reentrenando los pesos y añadiendo validaciones en `tests/nnue/feature_sanity.cpp`. | Elo en SPRT STC 10+0.1 y precisión del evaluador en posiciones `mate-in-x`. | Riesgo de sobreajuste: conservar una versión congelada del dataset y comparar RMSE contra la red actual antes de lanzar campañas. |

## Próximos pasos sugeridos

1. Abrir una rama dedicada por tarea (`sprt/threat-extensions`, `sprt/tt-aging`, etc.) y dejar un commit base etiquetado (`tag: sprt-threat-extensions-v1`) antes de cada batería SPRT.
2. Reunir métricas preliminares con `nps` y `bench` antes de lanzar los tests SPRT para filtrar regresiones obvias.
3. Centralizar en `docs/sprt-results/` los reportes de cada corrida (log Fastchess, configuración y resultado) para mantener trazabilidad.
4. Si una tarea supera los umbrales SPRT definidos (por ejemplo, `LLR ≥ 2.0` con `elo0=0`, `elo1=3`), fusionar en la rama principal y repetir el proceso con la siguiente propuesta.
